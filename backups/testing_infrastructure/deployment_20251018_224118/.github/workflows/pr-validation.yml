name: Pull Request Validation

on:
  pull_request:
    branches: [ main, develop ]
    types: [opened, synchronize, reopened, ready_for_review]

env:
  BUILD_TYPE: Release
  QT_VERSION: 6.5.0

jobs:
  # Quick validation for draft PRs
  draft-validation:
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == true
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Basic validation
        run: |
          echo "üîç Running basic validation for draft PR..."
          
          # Check for basic file structure
          if [ ! -f "CMakeLists.txt" ]; then
            echo "‚ùå CMakeLists.txt not found"
            exit 1
          fi
          
          # Check for obvious syntax errors in CMake files
          find . -name "CMakeLists.txt" -o -name "*.cmake" | xargs -I {} sh -c 'echo "Checking {}" && cmake -P {} --help > /dev/null 2>&1 || echo "Warning: {} may have syntax issues"'
          
          echo "‚úÖ Basic validation passed"

      - name: Comment on draft PR
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `## üìù Draft PR Validation
              
              Basic validation completed for this draft PR.
              
              ‚úÖ Project structure looks good
              ‚úÖ CMake files appear valid
              
              When you're ready for full validation, mark this PR as ready for review.`
            });

  # Full validation for ready PRs
  pr-validation:
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for better diff analysis

      - name: Setup Qt
        uses: jurplel/install-qt-action@v3
        with:
          version: ${{ env.QT_VERSION }}
          cache: true

      - name: Setup CMake
        uses: jwlawson/actions-setup-cmake@v1.14
        with:
          cmake-version: '3.20'

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            ninja-build \
            libgl1-mesa-dev \
            libxkbcommon-x11-0 \
            libxcb-icccm4 \
            libxcb-image0 \
            libxcb-keysyms1 \
            libxcb-randr0 \
            libxcb-render-util0 \
            libxcb-xinerama0 \
            libxcb-xfixes0 \
            xvfb \
            gcovr

      - name: Analyze changed files
        id: changes
        run: |
          # Get list of changed files
          git diff --name-only origin/${{ github.base_ref }}...HEAD > changed_files.txt
          
          # Categorize changes
          HAS_SOURCE_CHANGES=$(grep -E '\.(cpp|cc|cxx|c)$' changed_files.txt | wc -l)
          HAS_HEADER_CHANGES=$(grep -E '\.(h|hpp|hxx)$' changed_files.txt | wc -l)
          HAS_CMAKE_CHANGES=$(grep -E '(CMakeLists\.txt|\.cmake)$' changed_files.txt | wc -l)
          HAS_TEST_CHANGES=$(grep -E '^tests/' changed_files.txt | wc -l)
          HAS_DOC_CHANGES=$(grep -E '\.(md|txt|rst)$' changed_files.txt | wc -l)
          
          echo "source_changes=$HAS_SOURCE_CHANGES" >> $GITHUB_OUTPUT
          echo "header_changes=$HAS_HEADER_CHANGES" >> $GITHUB_OUTPUT
          echo "cmake_changes=$HAS_CMAKE_CHANGES" >> $GITHUB_OUTPUT
          echo "test_changes=$HAS_TEST_CHANGES" >> $GITHUB_OUTPUT
          echo "doc_changes=$HAS_DOC_CHANGES" >> $GITHUB_OUTPUT
          
          echo "üìä Change Analysis:"
          echo "- Source files: $HAS_SOURCE_CHANGES"
          echo "- Header files: $HAS_HEADER_CHANGES"
          echo "- CMake files: $HAS_CMAKE_CHANGES"
          echo "- Test files: $HAS_TEST_CHANGES"
          echo "- Documentation: $HAS_DOC_CHANGES"

      - name: Configure CMake
        run: |
          cmake -B build -G Ninja \
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
            -DBUILD_TESTING=ON \
            -DENABLE_COVERAGE=ON

      - name: Build
        run: cmake --build build --config ${{ env.BUILD_TYPE }} --parallel 4

      - name: Run Unit Tests
        run: |
          mkdir -p test-results
          xvfb-run -a ctest --test-dir build --output-on-failure --verbose -L "unit" --output-junit test-results/unit-tests.xml

      - name: Run Integration Tests
        if: steps.changes.outputs.source_changes > 0 || steps.changes.outputs.header_changes > 0
        run: |
          xvfb-run -a ctest --test-dir build --output-on-failure --verbose -L "integration" --output-junit test-results/integration-tests.xml

      - name: Run Affected Tests
        if: steps.changes.outputs.test_changes > 0
        run: |
          # Run tests that might be affected by changes
          echo "Running tests affected by changes..."
          
          # Get list of changed test files
          grep -E '^tests/.*\.(cpp|cc|cxx)$' changed_files.txt > changed_tests.txt || true
          
          if [ -s changed_tests.txt ]; then
            echo "Changed test files:"
            cat changed_tests.txt
            
            # Run specific tests (this would need more sophisticated mapping)
            xvfb-run -a ctest --test-dir build --output-on-failure --verbose --output-junit test-results/affected-tests.xml
          fi

      - name: Generate Coverage Report
        if: steps.changes.outputs.source_changes > 0 || steps.changes.outputs.header_changes > 0
        run: |
          mkdir -p coverage-reports
          gcovr --root . --build-root build \
            --exclude-unreachable-branches \
            --exclude-throw-branches \
            --exclude 'tests/.*' \
            --exclude 'third_party/.*' \
            --html-details coverage-reports/coverage.html \
            --xml coverage-reports/coverage.xml \
            --json coverage-reports/coverage.json

      - name: Coverage Diff Analysis
        if: steps.changes.outputs.source_changes > 0 || steps.changes.outputs.header_changes > 0
        id: coverage-diff
        run: |
          # This would compare coverage with base branch
          # For now, just extract current coverage
          CURRENT_COVERAGE=$(python3 -c "
          import json
          try:
              with open('coverage-reports/coverage.json', 'r') as f:
                  data = json.load(f)
                  print(f\"{data.get('line_coverage', 0):.1f}\")
          except:
              print('0.0')
          " 2>/dev/null || echo "0.0")
          
          echo "current_coverage=$CURRENT_COVERAGE" >> $GITHUB_OUTPUT
          echo "Current coverage: $CURRENT_COVERAGE%"

      - name: Static Analysis
        if: steps.changes.outputs.source_changes > 0 || steps.changes.outputs.header_changes > 0
        run: |
          # Run static analysis on changed files only
          mkdir -p analysis-reports
          
          # Get changed source files
          grep -E '\.(cpp|cc|cxx|c|h|hpp|hxx)$' changed_files.txt > changed_source_files.txt || true
          
          if [ -s changed_source_files.txt ]; then
            echo "Running static analysis on changed files:"
            cat changed_source_files.txt
            
            # Install cppcheck if not available
            sudo apt-get install -y cppcheck
            
            # Run cppcheck on changed files
            cat changed_source_files.txt | xargs cppcheck \
              --enable=warning,style,performance,portability \
              --xml --xml-version=2 \
              --suppress=missingIncludeSystem \
              --suppress=unusedFunction \
              2> analysis-reports/cppcheck-pr.xml || true
          fi

      - name: Check for Breaking Changes
        id: breaking-changes
        run: |
          # Simple check for potential breaking changes
          BREAKING_CHANGES=0
          
          # Check for removed public functions/classes (simplified)
          if [ -s changed_files.txt ]; then
            # Look for removed lines in header files that might indicate API changes
            for file in $(grep -E '\.h(pp)?$' changed_files.txt); do
              if [ -f "$file" ]; then
                # Check git diff for removed public/protected members
                REMOVED_PUBLIC=$(git diff origin/${{ github.base_ref }}...HEAD -- "$file" | grep -c '^-.*public:' || echo "0")
                REMOVED_FUNCTIONS=$(git diff origin/${{ github.base_ref }}...HEAD -- "$file" | grep -c '^-.*(' || echo "0")
                
                if [ "$REMOVED_PUBLIC" -gt 0 ] || [ "$REMOVED_FUNCTIONS" -gt 5 ]; then
                  echo "‚ö†Ô∏è Potential breaking changes detected in $file"
                  BREAKING_CHANGES=$((BREAKING_CHANGES + 1))
                fi
              fi
            done
          fi
          
          echo "breaking_changes=$BREAKING_CHANGES" >> $GITHUB_OUTPUT
          
          if [ "$BREAKING_CHANGES" -gt 0 ]; then
            echo "‚ö†Ô∏è $BREAKING_CHANGES potential breaking changes detected"
          else
            echo "‚úÖ No obvious breaking changes detected"
          fi

      - name: Performance Impact Analysis
        if: steps.changes.outputs.source_changes > 0
        run: |
          # Run a subset of performance tests to check for regressions
          echo "üîç Analyzing performance impact..."
          
          # Run quick performance tests
          xvfb-run -a ctest --test-dir build --verbose -L "performance" --timeout 300 --output-junit test-results/performance-quick.xml || echo "Performance tests completed with warnings"

      - name: Upload Test Results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: pr-test-results
          path: test-results/
          retention-days: 30

      - name: Upload Coverage Reports
        uses: actions/upload-artifact@v4
        if: steps.changes.outputs.source_changes > 0 || steps.changes.outputs.header_changes > 0
        with:
          name: pr-coverage-reports
          path: coverage-reports/
          retention-days: 30

      - name: Upload Analysis Reports
        uses: actions/upload-artifact@v4
        if: steps.changes.outputs.source_changes > 0 || steps.changes.outputs.header_changes > 0
        with:
          name: pr-analysis-reports
          path: analysis-reports/
          retention-days: 30

      - name: Comment PR with Results
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read test results
            let testResults = { passed: 0, failed: 0, total: 0 };
            try {
              const files = fs.readdirSync('test-results');
              for (const file of files) {
                if (file.endsWith('.xml')) {
                  const content = fs.readFileSync(`test-results/${file}`, 'utf8');
                  const tests = content.match(/tests="(\d+)"/);
                  const failures = content.match(/failures="(\d+)"/);
                  const errors = content.match(/errors="(\d+)"/);
                  
                  if (tests) testResults.total += parseInt(tests[1]);
                  if (failures) testResults.failed += parseInt(failures[1]);
                  if (errors) testResults.failed += parseInt(errors[1]);
                }
              }
              testResults.passed = testResults.total - testResults.failed;
            } catch (e) {
              console.log('Could not read test results');
            }
            
            const sourceChanges = '${{ steps.changes.outputs.source_changes }}';
            const headerChanges = '${{ steps.changes.outputs.header_changes }}';
            const testChanges = '${{ steps.changes.outputs.test_changes }}';
            const breakingChanges = '${{ steps.breaking-changes.outputs.breaking_changes }}';
            const currentCoverage = '${{ steps.coverage-diff.outputs.current_coverage }}';
            
            const testsPassed = testResults.failed === 0;
            const hasCodeChanges = parseInt(sourceChanges) > 0 || parseInt(headerChanges) > 0;
            const hasBreakingChanges = parseInt(breakingChanges) > 0;
            
            let status = '‚úÖ';
            let statusText = 'All checks passed';
            
            if (!testsPassed) {
              status = '‚ùå';
              statusText = 'Tests failed';
            } else if (hasBreakingChanges) {
              status = '‚ö†Ô∏è';
              statusText = 'Potential breaking changes detected';
            }
            
            const body = `## ${status} PR Validation Results
            
            ### üìä Change Summary
            - **Source files changed:** ${sourceChanges}
            - **Header files changed:** ${headerChanges}
            - **Test files changed:** ${testChanges}
            - **Breaking changes:** ${breakingChanges > 0 ? '‚ö†Ô∏è ' + breakingChanges + ' potential' : '‚úÖ None detected'}
            
            ### üß™ Test Results
            - **Total tests:** ${testResults.total}
            - **Passed:** ${testResults.passed}
            - **Failed:** ${testResults.failed}
            - **Status:** ${testsPassed ? '‚úÖ All tests passed' : '‚ùå Some tests failed'}
            
            ${hasCodeChanges ? `### üìà Coverage
            - **Current coverage:** ${currentCoverage}%
            ` : ''}
            
            ### üéØ Overall Status: ${statusText}
            
            ${hasBreakingChanges ? `
            ‚ö†Ô∏è **Warning:** This PR may contain breaking changes. Please review carefully and update documentation if needed.
            ` : ''}
            
            ${!testsPassed ? `
            ‚ùå **Action Required:** Some tests are failing. Please fix the failing tests before merging.
            ` : ''}
            
            [View detailed results](${context.payload.repository.html_url}/actions/runs/${context.runId})
            `;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Set PR Status
        if: always()
        run: |
          if [ "${{ steps.changes.outputs.source_changes }}" -gt 0 ] || [ "${{ steps.changes.outputs.header_changes }}" -gt 0 ]; then
            # Check if tests passed and no breaking changes
            if [ -f test-results/unit-tests.xml ]; then
              UNIT_FAILURES=$(grep -o 'failures="[0-9]*"' test-results/unit-tests.xml | grep -o '[0-9]*' || echo "0")
              UNIT_ERRORS=$(grep -o 'errors="[0-9]*"' test-results/unit-tests.xml | grep -o '[0-9]*' || echo "0")
              
              TOTAL_FAILURES=$((UNIT_FAILURES + UNIT_ERRORS))
              
              if [ "$TOTAL_FAILURES" -gt 0 ]; then
                echo "‚ùå PR validation failed: $TOTAL_FAILURES test failures"
                exit 1
              fi
            fi
            
            if [ "${{ steps.breaking-changes.outputs.breaking_changes }}" -gt 0 ]; then
              echo "‚ö†Ô∏è PR validation warning: Potential breaking changes detected"
              # Don't fail the build, but warn
            fi
          fi
          
          echo "‚úÖ PR validation passed"

  # Auto-merge for specific types of PRs (optional)
  auto-merge-check:
    needs: pr-validation
    runs-on: ubuntu-latest
    if: |
      github.event.pull_request.draft == false &&
      contains(github.event.pull_request.labels.*.name, 'auto-merge') &&
      github.actor == 'dependabot[bot]'
    
    steps:
      - name: Auto-merge dependabot PRs
        uses: actions/github-script@v7
        with:
          script: |
            // Only auto-merge if all checks passed and it's a dependabot PR
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            if (pr.user.login === 'dependabot[bot]' && pr.mergeable) {
              await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number,
                merge_method: 'squash'
              });
              
              console.log('Auto-merged dependabot PR');
            } else {
              console.log('PR not eligible for auto-merge');
            }